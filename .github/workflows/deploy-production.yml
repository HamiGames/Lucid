name: Production Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      namespace:
        description: 'Kubernetes namespace'
        required: true
        default: 'lucid-system'
        type: string
      image_tag:
        description: 'Container image tag'
        required: false
        default: 'latest'
        type: string
      force_deploy:
        description: 'Force deployment even if health checks fail'
        required: false
        default: false
        type: boolean
  push:
    branches:
      - main
    paths:
      - 'infrastructure/kubernetes/**'
      - 'scripts/deployment/**'
      - '.github/workflows/deploy-production.yml'

env:
  REGISTRY: pickme
  IMAGE_NAME: lucid

jobs:
  pre-deployment-checks:
    name: Pre-deployment Checks
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Check cluster connectivity
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Check namespace
        run: |
          if ! kubectl get namespace ${{ github.event.inputs.namespace || 'lucid-system' }}; then
            echo "Namespace does not exist, will be created during deployment"
          fi

      - name: Check required images
        run: |
          # Check if required images exist in registry
          docker pull ghcr.io/${{ github.repository }}/lucid-api-gateway:${{ github.event.inputs.image_tag || 'latest' }} || echo "Image not found"
          docker pull ghcr.io/${{ github.repository }}/lucid-blockchain-engine:${{ github.event.inputs.image_tag || 'latest' }} || echo "Image not found"
          docker pull ghcr.io/${{ github.repository }}/lucid-session-management:${{ github.event.inputs.image_tag || 'latest' }} || echo "Image not found"

      - name: Check deployment readiness
        id: check
        run: |
          echo "should-deploy=true" >> $GITHUB_OUTPUT

  build-and-push:
    name: Build and Push Images
    runs-on: ubuntu-latest
    needs: pre-deployment-checks
    if: needs.pre-deployment-checks.outputs.should-deploy == 'true'
    strategy:
      matrix:
        service:
          - api-gateway
          - blockchain-engine
          - session-management
          - rdp-services
          - node-management
          - admin-interface
          - tron-payment
          - auth-service
          - service-mesh-controller
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/lucid-${{ matrix.service }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=${{ github.event.inputs.image_tag || 'latest' }}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: infrastructure/docker/${{ matrix.service }}/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64,linux/arm64

  deploy-to-kubernetes:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    needs: [pre-deployment-checks, build-and-push]
    if: always() && needs.pre-deployment-checks.outputs.should-deploy == 'true'
    environment: 
      name: ${{ github.event.inputs.environment || 'production' }}
      url: https://api.lucid.onion
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Create namespace
        run: |
          kubectl create namespace ${{ github.event.inputs.namespace || 'lucid-system' }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Update image tags in Kubernetes manifests
        run: |
          # Update image tags in kustomization.yaml
          sed -i "s/newTag: latest/newTag: ${{ github.event.inputs.image_tag || 'latest' }}/g" infrastructure/kubernetes/kustomization.yaml
          
          # Update image tags in individual manifests
          find infrastructure/kubernetes -name "*.yaml" -exec sed -i "s/:latest/:${{ github.event.inputs.image_tag || 'latest' }}/g" {} \;

      - name: Deploy to Kubernetes
        run: |
          chmod +x scripts/deployment/deploy-k8s.sh
          ./scripts/deployment/deploy-k8s.sh \
            --namespace ${{ github.event.inputs.namespace || 'lucid-system' }} \
            --environment ${{ github.event.inputs.environment || 'production' }}

      - name: Wait for deployment to complete
        run: |
          kubectl rollout status deployment/api-gateway -n ${{ github.event.inputs.namespace || 'lucid-system' }} --timeout=600s
          kubectl rollout status deployment/blockchain-engine -n ${{ github.event.inputs.namespace || 'lucid-system' }} --timeout=600s
          kubectl rollout status deployment/session-management -n ${{ github.event.inputs.namespace || 'lucid-system' }} --timeout=600s

      - name: Run health checks
        run: |
          chmod +x scripts/deployment/health-check-k8s.sh
          ./scripts/deployment/health-check-k8s.sh \
            --namespace ${{ github.event.inputs.namespace || 'lucid-system' }} \
            --timeout 60 \
            --verbose

      - name: Get deployment status
        if: always()
        run: |
          echo "=== Deployment Status ==="
          kubectl get all -n ${{ github.event.inputs.namespace || 'lucid-system' }}
          
          echo ""
          echo "=== Pod Status ==="
          kubectl get pods -n ${{ github.event.inputs.namespace || 'lucid-system' }} -o wide
          
          echo ""
          echo "=== Service Status ==="
          kubectl get services -n ${{ github.event.inputs.namespace || 'lucid-system' }}
          
          echo ""
          echo "=== Ingress Status ==="
          kubectl get ingress -n ${{ github.event.inputs.namespace || 'lucid-system' }} || echo "No ingress found"

  post-deployment-verification:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: deploy-to-kubernetes
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Verify all services are running
        run: |
          # Check all deployments are ready
          kubectl get deployments -n ${{ github.event.inputs.namespace || 'lucid-system' }} -o jsonpath='{.items[*].status.conditions[?(@.type=="Available")].status}' | grep -q "True"
          
          # Check all pods are running
          kubectl get pods -n ${{ github.event.inputs.namespace || 'lucid-system' }} --field-selector=status.phase!=Running,status.phase!=Succeeded --no-headers | wc -l | grep -q "^0$"

      - name: Test API endpoints
        run: |
          # Get API Gateway service endpoint
          API_GATEWAY_IP=$(kubectl get service api-gateway -n ${{ github.event.inputs.namespace || 'lucid-system' }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          if [[ -z "$API_GATEWAY_IP" ]]; then
            API_GATEWAY_IP=$(kubectl get service api-gateway -n ${{ github.event.inputs.namespace || 'lucid-system' }} -o jsonpath='{.spec.clusterIP}')
          fi
          
          # Test health endpoint
          curl -f "http://$API_GATEWAY_IP:8080/health" || echo "Health check failed"

      - name: Generate deployment report
        run: |
          echo "=== Deployment Report ==="
          echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "Namespace: ${{ github.event.inputs.namespace || 'lucid-system' }}"
          echo "Image Tag: ${{ github.event.inputs.image_tag || 'latest' }}"
          echo "Deployment Time: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          echo "Commit: ${{ github.sha }}"
          echo "Branch: ${{ github.ref_name }}"
          
          echo ""
          echo "=== Resource Summary ==="
          kubectl get all -n ${{ github.event.inputs.namespace || 'lucid-system' }} --no-headers | wc -l | xargs echo "Total resources:"
          
          echo ""
          echo "=== Service Endpoints ==="
          kubectl get services -n ${{ github.event.inputs.namespace || 'lucid-system' }} -o custom-columns="NAME:.metadata.name,CLUSTER-IP:.spec.clusterIP,EXTERNAL-IP:.status.loadBalancer.ingress[0].ip,PORT(S):.spec.ports[*].port"

  rollback-on-failure:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [deploy-to-kubernetes, post-deployment-verification]
    if: failure() && needs.deploy-to-kubernetes.result != 'skipped'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ secrets.KUBE_CONFIG }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig

      - name: Rollback deployment
        run: |
          chmod +x scripts/deployment/rollback-k8s.sh
          ./scripts/deployment/rollback-k8s.sh \
            --namespace ${{ github.event.inputs.namespace || 'lucid-system' }}

      - name: Verify rollback
        run: |
          kubectl get pods -n ${{ github.event.inputs.namespace || 'lucid-system' }}
          kubectl get deployments -n ${{ github.event.inputs.namespace || 'lucid-system' }}

  notify-deployment-status:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [deploy-to-kubernetes, post-deployment-verification, rollback-on-failure]
    if: always()
    steps:
      - name: Notify success
        if: needs.post-deployment-verification.result == 'success'
        run: |
          echo "✅ Production deployment completed successfully!"
          echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "Namespace: ${{ github.event.inputs.namespace || 'lucid-system' }}"
          echo "Access URL: https://api.lucid.onion"

      - name: Notify failure
        if: needs.post-deployment-verification.result == 'failure'
        run: |
          echo "❌ Production deployment failed!"
          echo "Environment: ${{ github.event.inputs.environment || 'production' }}"
          echo "Namespace: ${{ github.event.inputs.namespace || 'lucid-system' }}"
          echo "Check the logs for details."
