# Multi-stage distroless build for Lucid Service Mesh Controller
# Step 32: Phase 2 Container Builds - Core Services
# Aligned with essentials.md: pickme/lucid-service-mesh-controller:latest-arm64, ports 8500,8501,8502,8600,8088, IP 172.20.0.19
# Network Configuration: lucid-pi-network (172.20.0.0/16)
# Fully aligned with plan/constants/ directory requirements

# Stage 1: Builder (use TARGETPLATFORM for cross-platform ARM64 builds with QEMU emulation)
FROM --platform=$TARGETPLATFORM python:3.11-slim AS builder

# Set shell to bash for Linux compatibility (standard Linux syntax)
SHELL ["/bin/bash", "-c"]

# Set build arguments (aligned with path_plan.md)
ARG BUILDPLATFORM
ARG TARGETPLATFORM=linux/arm64
ARG BUILD_DATE
ARG VCS_REF
ARG VERSION=1.0.0
ARG GIT_COMMIT=unknown
ARG PYTHON_VERSION=3.11

# Set environment variables for pip optimization (aligned with path_plan.md)
ENV DEBIAN_FRONTEND=noninteractive \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PIP_DEFAULT_TIMEOUT=100 \
    PIP_PREFER_BINARY=1

# Install build dependencies with apt cache mount (BuildKit optimization)
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    apt-get update && apt-get install -y \
    build-essential \
    gcc \
    g++ \
    libffi-dev \
    libssl-dev \
    pkg-config \
    curl \
    git \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Create placeholder files in system directories with actual content (ensures they're baked into image)
RUN echo "LUCID_SERVICE_MESH_CONTROLLER_RUNTIME_DIRECTORY" > /var/run/.keep && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_LIB_DIRECTORY" > /var/lib/.keep && \
    chown -R 65532:65532 /var/run /var/lib

# Upgrade pip tooling to latest versions so binary wheels resolve properly
RUN --mount=type=cache,target=/root/.cache/pip \
    python -m pip install --upgrade pip wheel setuptools

# Copy requirements and install dependencies
COPY infrastructure/service-mesh/requirements.txt ./requirements.txt

# Verify requirements.txt was copied (per Dockerfile-copy-pattern: verify before use)
RUN test -f ./requirements.txt || (echo "ERROR: requirements.txt not found" && exit 1) && \
    echo "✅ requirements.txt verified in builder stage"

# Ensure directory structure exists before pip install
RUN mkdir -p /root/.local/lib/python3.11/site-packages && \
    mkdir -p /root/.local/bin

# Install Python dependencies with cache mount and optimizations
# Explicitly install core runtime packages even if requirements.txt omits them.
RUN --mount=type=cache,target=/root/.cache/pip \
    --mount=type=cache,target=/root/.cache/pip/wheels \
    python -m pip install --user \
        --prefer-binary \
        --no-warn-script-location \
        -r requirements.txt && \
    python -m pip install --user \
        --prefer-binary \
        --no-warn-script-location \
        grpcio \
        aiohttp \
        python-consul \
        pydantic \
        cryptography && \
    python -m pip check

# Create marker files with actual content (ensures directory structure is locked in)
# CRITICAL: Must be AFTER pip install, with actual content (not empty)
RUN echo "LUCID_SERVICE_MESH_CONTROLLER_PACKAGES_INSTALLED_$(date +%s)" > /root/.local/lib/python3.11/site-packages/.lucid-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_BINARIES_INSTALLED_$(date +%s)" > /root/.local/bin/.lucid-marker && \
    chown -R 65532:65532 /root/.local

# Verify packages are installed and verify directory structure
RUN test -d /root/.local/lib/python3.11/site-packages && \
    echo "Directory exists: /root/.local/lib/python3.11/site-packages" && \
    ls -la /root/.local/lib/python3.11/site-packages/ | head -20 && \
    echo "Package count: $(ls -1 /root/.local/lib/python3.11/site-packages/ | wc -l)" && \
    PYTHONPATH=/root/.local/lib/python3.11/site-packages:$PYTHONPATH python3 - <<'PY'
from importlib import import_module
import sys
required = ("grpcio", "aiohttp", "python_consul", "pydantic", "cryptography")
failed = []
for module in required:
    try:
        import_module(module)
        print(f"✅ {module} imported successfully")
    except ImportError as e:
        print(f"❌ {module} import failed: {e}", file=sys.stderr)
        failed.append(module)
if failed:
    print(f"ERROR: Failed to import: {', '.join(failed)}", file=sys.stderr)
    sys.exit(1)
print("✅ critical packages installed and importable")
PY

# Copy service mesh controller source code to builder stage
# CRITICAL: Use full path from build context root (build context is .)
COPY infrastructure/service-mesh/controller/ ./controller/
COPY infrastructure/service-mesh/sidecar/ ./sidecar/
COPY infrastructure/service-mesh/discovery/ ./discovery/
COPY infrastructure/service-mesh/communication/ ./communication/
COPY infrastructure/service-mesh/security/ ./security/

# Verify source code directories were copied (per Dockerfile-copy-pattern: verify after COPY)
# CRITICAL: This prevents silent COPY failures for source code
RUN test -d ./controller || (echo "ERROR: controller directory not copied" && exit 1) && \
    test -d ./sidecar || (echo "ERROR: sidecar directory not copied" && exit 1) && \
    test -d ./discovery || (echo "ERROR: discovery directory not copied" && exit 1) && \
    test -d ./communication || (echo "ERROR: communication directory not copied" && exit 1) && \
    test -d ./security || (echo "ERROR: security directory not copied" && exit 1) && \
    echo "✅ Source code directories verified in builder stage"

# Lock in source directory structure with marker files (per Dockerfile-copy-pattern)
# CRITICAL: Create marker files with actual content AFTER copying source code
RUN echo "LUCID_SERVICE_MESH_CONTROLLER_SOURCE_$(date +%s)" > /app/controller/.lucid-source-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_SIDECAR_$(date +%s)" > /app/sidecar/.lucid-sidecar-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_DISCOVERY_$(date +%s)" > /app/discovery/.lucid-discovery-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_COMMUNICATION_$(date +%s)" > /app/communication/.lucid-communication-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_SECURITY_$(date +%s)" > /app/security/.lucid-security-marker && \
    chown -R 65532:65532 /app

# Build the application
RUN python -m compileall -b .

# Verify system libraries exist in builder stage before COPY (per Dockerfile-copy-pattern)
# CRITICAL: This ensures COPY operations will not fail silently
RUN test -f /lib/ld-linux-aarch64.so.1 || (echo "ERROR: /lib/ld-linux-aarch64.so.1 not found in builder stage" && exit 1) && \
    test -d /lib/aarch64-linux-gnu || (echo "ERROR: /lib/aarch64-linux-gnu directory not found in builder stage" && exit 1) && \
    test -f /etc/ssl/certs/ca-certificates.crt || (echo "ERROR: /etc/ssl/certs/ca-certificates.crt not found in builder stage" && exit 1) && \
    echo "✅ System libraries verified in builder stage: dynamic linker, arch-specific libs, CA certificates"

# Stage 2: Runtime (Distroless) - use TARGETPLATFORM for final image
FROM --platform=$TARGETPLATFORM gcr.io/distroless/python3-debian12

# Set build arguments for labels
ARG BUILD_DATE
ARG VCS_REF
ARG VERSION=1.0.0
ARG TARGETPLATFORM=linux/arm64

# Set metadata labels (aligned with essentials.md)
LABEL maintainer="Lucid Development Team" \
      org.opencontainers.image.title="Lucid Service Mesh Controller" \
      org.opencontainers.image.description="Distroless service mesh controller for Lucid platform" \
      org.opencontainers.image.version="${VERSION}" \
      org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.revision="${VCS_REF}" \
      org.opencontainers.image.vendor="Lucid" \
      org.opencontainers.image.licenses="MIT" \
      lucid.service="service-mesh-controller" \
      lucid.type="distroless" \
      lucid.platform="arm64" \
      lucid.security="hardened" \
      phase="2" \
      cluster="10-cross-cluster-integration"

# Set working directory
WORKDIR /app

# Copy runtime directories from builder (directory already populated with .keep files)
COPY --from=builder --chown=65532:65532 /var/run /var/run
COPY --from=builder --chown=65532:65532 /var/lib /var/lib

# Verify runtime directories were copied (per Dockerfile-copy-pattern: verify after COPY)
RUN ["/usr/bin/python3.11", "-c", "import os; assert os.path.exists('/var/run/.keep'), 'Runtime directory not copied: /var/run'; assert os.path.exists('/var/lib/.keep'), 'Lib directory not copied: /var/lib'; print('✅ Runtime directories verified in runtime stage')"]

# Copy Python packages (directory already populated with packages + marker files from builder stage)
COPY --from=builder --chown=65532:65532 /root/.local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder --chown=65532:65532 /root/.local/bin /usr/local/bin

# Copy dynamic linker for ARM64 (required for native extensions like grpcio)
COPY --from=builder /lib/ld-linux-aarch64.so.1 /lib/ld-linux-aarch64.so.1

# Copy arch-specific libraries directory (required for ARM64 native extensions)
COPY --from=builder /lib/aarch64-linux-gnu /lib/aarch64-linux-gnu

# Copy CA certificates (required for SSL/TLS operations)
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt

# Verify system libraries were copied (per Dockerfile-copy-pattern: verify after COPY)
# CRITICAL: This will fail the build if system libraries are missing (prevents silent failures)
RUN ["/usr/bin/python3.11", "-c", "import os; assert os.path.exists('/lib/ld-linux-aarch64.so.1'), 'Dynamic linker not copied: /lib/ld-linux-aarch64.so.1'; assert os.path.isdir('/lib/aarch64-linux-gnu'), 'Arch-specific libs not copied: /lib/aarch64-linux-gnu'; assert os.path.exists('/etc/ssl/certs/ca-certificates.crt'), 'CA certificates not copied: /etc/ssl/certs/ca-certificates.crt'; print('✅ System libraries verified in runtime stage')"]

# Verify packages were copied (this will fail the build if packages are missing)
RUN ["/usr/bin/python3.11", "-c", "import os, importlib, importlib.util; site_packages = '/usr/local/lib/python3.11/site-packages'; assert os.path.exists(site_packages), f'{site_packages} does not exist'; required = ('grpcio', 'aiohttp', 'python_consul', 'pydantic', 'cryptography'); failed = [pkg for pkg in required if not importlib.util.find_spec(pkg)]; assert len(failed) == 0, f'Packages not found: {failed}'; [importlib.import_module(pkg) for pkg in required]; assert os.path.exists(os.path.join(site_packages, '.lucid-marker')), 'marker file not found'; print('Packages verified in runtime stage')"]

# Copy application code from builder (directory already populated with source + marker files)
COPY --from=builder --chown=65532:65532 /app /app

# Verify controller module exists (this will fail the build if module is missing)
RUN ["/usr/bin/python3.11", "-c", "import os, importlib.util; assert os.path.exists('/app/controller'), 'controller directory missing'; assert os.path.exists('/app/controller/.lucid-source-marker'), 'controller marker file missing'; assert os.path.exists('/app/sidecar'), 'sidecar directory missing'; assert os.path.exists('/app/discovery'), 'discovery directory missing'; assert os.path.exists('/app/communication'), 'communication directory missing'; assert os.path.exists('/app/security'), 'security directory missing'; assert importlib.util.find_spec('controller.main', package=None), 'controller.main not found'; print('controller package verified in runtime stage')"]

# Locale and Timezone Configuration (distroless-compatible: C.UTF-8)
ENV TZ=UTC \
    LANG=C.UTF-8 \
    LC_ALL=C.UTF-8 \
    COUNTRY=US

# Set Python path and environment (packages already copied above)
ENV PYTHONPATH=/app:/usr/local/lib/python3.11/site-packages \
    PATH=/usr/local/bin:$PATH \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    LUCID_ENV=production \
    LUCID_PLATFORM=arm64 \
    LUCID_ARCHITECTURE=linux/arm64

# Service Configuration (per essentials.md and Network_conig_requirements.md lines 307-360)
ENV SERVICE_NAME=service-mesh-controller \
    CONTAINER_NAME=lucid-service-mesh-controller \
    HOSTNAME=lucid-service-mesh-controller

# Port Configuration
ENV PORT=8500 \
    SERVICE_MESH_CONTROLLER_PORT=8500 \
    HEALTHCHECK_PORT=8500 \
    HEALTHCHECK_PATH=/v1/status/leader

# Network Configuration (per Network_conig_requirements.md lines 334-341)
ENV SERVICE_MESH_CONTROLLER_HOST=172.20.0.19 \
    SERVICE_DISCOVERY_URL=http://lucid-service-mesh-controller:8500 \
    SERVICE_MESH_ENABLED=true

# Consul Configuration (per Network_conig_requirements.md lines 334-341)
ENV CONSUL_PORT=8500 \
    CONSUL_DATACENTER=lucid-dc \
    CONSUL_BOOTSTRAP_EXPECT=1 \
    CONSUL_UI_ENABLED=true \
    CONSUL_CONNECT_ENABLED=true \
    CONSUL_NODE_NAME=lucid-service-mesh-controller

# Database Configuration (per Network_conig_requirements.md - if needed)
# Note: MONGODB_PASSWORD will be provided via .env files at runtime
ENV MONGODB_URI=mongodb://lucid:${MONGODB_PASSWORD:-changeme}@lucid-mongodb:27017/lucid?authSource=admin \
    REDIS_URL=redis://lucid-redis:6379/0

# Project Configuration (per path_plan.md)
ENV PROJECT_ROOT=/mnt/myssd/Lucid/Lucid \
    PROJECT_NAME=Lucid \
    PROJECT_VERSION=0.1.0

# Logging Configuration (per path_plan.md)
ENV LOG_LEVEL=INFO \
    DEBUG=false \
    LOG_FORMAT=json

# Network Configuration (per network_defs.md)
ENV LUCID_PI_NETWORK=lucid-pi-network \
    LUCID_PI_SUBNET=172.20.0.0/16 \
    LUCID_PI_GATEWAY=172.20.0.1

# Use nonroot user (distroless default)
USER 65532:65532

# Health check (aligned with essentials.md and Network_conig_requirements.md: healthcheck_port=8500, healthcheck_path=/v1/status/leader)
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD ["python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8500/v1/status/leader')"]

# Expose ports (aligned with essentials.md and Network_conig_requirements.md: 8500,8501,8502,8600,8088)
EXPOSE 8500 8501 8502 8600 8088

# Start application (async main in controller.main) - NOT FastAPI, uses asyncio.run(main())
CMD ["python3", "-c", "import asyncio; from controller.main import main; asyncio.run(main())"]
