# Multi-stage distroless build for Lucid Service Mesh Controller
# Step 32: Phase 2 Container Builds - Core Services
# Aligned with essentials.md: pickme/lucid-service-mesh-controller:latest-arm64, ports 8500,8501,8502,8600,8088, IP 172.20.0.19
# Network Configuration: lucid-pi-network (172.20.0.0/16)
# Fully aligned with plan/constants/ directory requirements

# Stage 1: Builder (use TARGETPLATFORM for cross-platform ARM64 builds with QEMU emulation)
FROM --platform=$TARGETPLATFORM python:3.11-slim AS builder

# Set shell to bash for Linux compatibility (standard Linux syntax)
SHELL ["/bin/bash", "-c"]

# Set build arguments (aligned with path_plan.md)
ARG BUILDPLATFORM
ARG TARGETPLATFORM=linux/arm64
ARG BUILD_DATE
ARG VCS_REF
ARG VERSION=1.0.0
ARG GIT_COMMIT=unknown
ARG PYTHON_VERSION=3.11

# Set environment variables for pip optimization (aligned with path_plan.md)
ENV DEBIAN_FRONTEND=noninteractive \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PIP_DEFAULT_TIMEOUT=100 \
    PIP_PREFER_BINARY=1

# Install build dependencies with apt cache mount (BuildKit optimization)
RUN --mount=type=cache,target=/var/cache/apt,sharing=locked \
    --mount=type=cache,target=/var/lib/apt,sharing=locked \
    (apt-get update || (echo "ERROR: apt-get update failed" && exit 1)) && \
    (apt-get install -y \
        build-essential \
        gcc \
        g++ \
        libffi-dev \
        libssl-dev \
        pkg-config \
        curl \
        git \
        ca-certificates || (echo "ERROR: apt-get install failed" && exit 1)) && \
    rm -rf /var/lib/apt/lists/* && \
    test -f /usr/bin/gcc || (echo "ERROR: gcc not installed" && exit 1) && \
    test -f /usr/bin/g++ || (echo "ERROR: g++ not installed" && exit 1)

# Set working directory
WORKDIR /app

# Create placeholder files in system directories with actual content (ensures they're baked into image)
RUN echo "LUCID_SERVICE_MESH_CONTROLLER_RUNTIME_DIRECTORY" > /var/run/.keep && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_LIB_DIRECTORY" > /var/lib/.keep && \
    test -f /var/run/.keep || (echo "ERROR: Failed to create /var/run/.keep" && exit 1) && \
    test -f /var/lib/.keep || (echo "ERROR: Failed to create /var/lib/.keep" && exit 1) && \
    chown -R 65532:65532 /var/run /var/lib || (echo "ERROR: Failed to chown runtime directories" && exit 1)

# Upgrade pip tooling to latest versions so binary wheels resolve properly
RUN --mount=type=cache,target=/root/.cache/pip \
    python -m pip install --upgrade pip wheel setuptools || (echo "ERROR: pip upgrade failed" && exit 1)

# Copy requirements and install dependencies
COPY infrastructure/service-mesh/requirements.txt ./requirements.txt

# Verify requirements.txt was copied (per Dockerfile-copy-pattern: verify before use)
RUN test -f ./requirements.txt || (echo "ERROR: requirements.txt not found" && exit 1) && \
    echo "✅ requirements.txt verified in builder stage"

# Ensure directory structure exists before pip install
RUN mkdir -p /root/.local/lib/python3.11/site-packages && \
    mkdir -p /root/.local/bin && \
    test -d /root/.local/lib/python3.11/site-packages || (echo "ERROR: Failed to create site-packages directory" && exit 1) && \
    test -d /root/.local/bin || (echo "ERROR: Failed to create bin directory" && exit 1)

# Install Python dependencies with cache mount and optimizations
# CRITICAL: Install PyYAML FIRST explicitly to ensure it's present before other packages
# Note: grpcio is already in requirements.txt, so we don't need to install it again
RUN --mount=type=cache,target=/root/.cache/pip \
    --mount=type=cache,target=/root/.cache/pip/wheels \
    (python -m pip install --user \
        --prefer-binary \
        --no-warn-script-location \
        PyYAML==6.0.1 || (echo "ERROR: PyYAML installation failed" && exit 1)) && \
    (python -m pip install --user \
        --prefer-binary \
        --no-warn-script-location \
        -r requirements.txt || (echo "ERROR: requirements.txt installation failed" && exit 1)) && \
    (python -m pip install --user \
        --prefer-binary \
        --no-warn-script-location \
        aiohttp \
        python-consul \
        pydantic \
        cryptography || (echo "ERROR: additional packages installation failed" && exit 1)) && \
    (python -m pip check || (echo "ERROR: pip dependency check failed" && exit 1)) && \
    (python -m pip list | grep -i "yaml\|PyYAML" || (echo "ERROR: PyYAML not found in pip list" && exit 1)) && \
    (test -d /root/.local/lib/python3.11/site-packages/yaml || test -f /root/.local/lib/python3.11/site-packages/yaml.py || (echo "ERROR: yaml package not found in site-packages" && exit 1)) && \
    (python -c "import sys; sys.path.insert(0, '/root/.local/lib/python3.11/site-packages'); import yaml; print('✅ PyYAML verified:', yaml.__file__)" || (echo "ERROR: yaml import failed" && exit 1))

# Create marker files with actual content (ensures directory structure is locked in)
# CRITICAL: Must be AFTER pip install, with actual content (not empty) per Dockerfile-copy-pattern
RUN test -d /root/.local/lib/python3.11/site-packages || (echo "ERROR: site-packages directory does not exist" && exit 1) && \
    test -d /root/.local/bin || (echo "ERROR: bin directory does not exist" && exit 1) && \
    marker_content_packages="LUCID_SERVICE_MESH_CONTROLLER_PACKAGES_INSTALLED_$(date +%s)" && \
    marker_content_binaries="LUCID_SERVICE_MESH_CONTROLLER_BINARIES_INSTALLED_$(date +%s)" && \
    echo "$marker_content_packages" > /root/.local/lib/python3.11/site-packages/.lucid-marker && \
    echo "$marker_content_binaries" > /root/.local/bin/.lucid-marker && \
    test -f /root/.local/lib/python3.11/site-packages/.lucid-marker || (echo "ERROR: Failed to create packages marker file" && exit 1) && \
    test -f /root/.local/bin/.lucid-marker || (echo "ERROR: Failed to create binaries marker file" && exit 1) && \
    test -s /root/.local/lib/python3.11/site-packages/.lucid-marker || (echo "ERROR: Packages marker file is empty" && exit 1) && \
    test -s /root/.local/bin/.lucid-marker || (echo "ERROR: Binaries marker file is empty" && exit 1) && \
    chown -R 65532:65532 /root/.local || (echo "ERROR: Failed to chown /root/.local" && exit 1)

# Verify packages are installed and verify directory structure
# CRITICAL: Use correct import names (grpc not grpcio, consul not python_consul)
# CRITICAL: Verify both package directories exist AND packages can be imported (per Dockerfile-copy-pattern)
RUN test -d /root/.local/lib/python3.11/site-packages || (echo "ERROR: site-packages directory missing" && exit 1) && \
    test -d /root/.local/bin || (echo "ERROR: bin directory missing" && exit 1) && \
    echo "Directory exists: /root/.local/lib/python3.11/site-packages" && \
    ls -la /root/.local/lib/python3.11/site-packages/ | head -20 && \
    package_count=$(ls -1 /root/.local/lib/python3.11/site-packages/ | wc -l) && \
    test "$package_count" -gt 0 || (echo "ERROR: No packages found in site-packages" && exit 1) && \
    echo "Package count: $package_count" && \
    PYTHONPATH=/root/.local/lib/python3.11/site-packages:$PYTHONPATH python3 - <<'PY'
from importlib import import_module
import sys
import os
# Note: grpcio package imports as 'grpc', python-consul package imports as 'consul', PyYAML package imports as 'yaml'
required = {"grpc": "grpc", "aiohttp": "aiohttp", "consul": "consul", "pydantic": "pydantic", "cryptography": "cryptography", "yaml": "yaml"}
site_packages = "/root/.local/lib/python3.11/site-packages"
failed_imports = []
failed_dirs = []
for pkg_name, import_name in required.items():
    pkg_dir = os.path.join(site_packages, pkg_name)
    pkg_file = os.path.join(site_packages, f"{pkg_name}.py")
    # Check for both directory and .py file (PyYAML might install as either)
    if not os.path.exists(pkg_dir) and not os.path.exists(pkg_file):
        print(f"❌ {pkg_name} not found (checked {pkg_dir} and {pkg_file})", file=sys.stderr)
        failed_dirs.append(pkg_name)
    try:
        import_module(import_name)
        print(f"✅ {import_name} imported successfully")
    except ImportError as e:
        print(f"❌ {import_name} import failed: {e}", file=sys.stderr)
        failed_imports.append(import_name)
if failed_dirs:
    print(f"ERROR: Package directories not found: {', '.join(failed_dirs)}", file=sys.stderr)
    sys.exit(1)
if failed_imports:
    print(f"ERROR: Failed to import: {', '.join(failed_imports)}", file=sys.stderr)
    sys.exit(1)
print("✅ critical packages installed and importable: all directories exist and imports work")
PY

# Copy service mesh controller source code to builder stage
# CRITICAL: Use full path from build context root (build context is .)
COPY infrastructure/service-mesh/controller/ ./controller/
COPY infrastructure/service-mesh/sidecar/ ./sidecar/
COPY infrastructure/service-mesh/discovery/ ./discovery/
COPY infrastructure/service-mesh/communication/ ./communication/
COPY infrastructure/service-mesh/security/ ./security/
COPY infrastructure/service-mesh/entrypoint.py ./entrypoint.py

# Verify source code directories were copied (per Dockerfile-copy-pattern: verify after COPY)
# CRITICAL: This prevents silent COPY failures for source code
RUN test -d ./controller || (echo "ERROR: controller directory not copied" && exit 1) && \
    test -d ./sidecar || (echo "ERROR: sidecar directory not copied" && exit 1) && \
    test -d ./discovery || (echo "ERROR: discovery directory not copied" && exit 1) && \
    test -d ./communication || (echo "ERROR: communication directory not copied" && exit 1) && \
    test -d ./security || (echo "ERROR: security directory not copied" && exit 1) && \
    test -f ./entrypoint.py || (echo "ERROR: entrypoint.py not copied" && exit 1) && \
    chmod +x ./entrypoint.py && \
    echo "✅ Source code directories verified in builder stage"

# Lock in source directory structure with marker files (per Dockerfile-copy-pattern)
# CRITICAL: Create marker files with actual content AFTER copying source code
RUN echo "LUCID_SERVICE_MESH_CONTROLLER_SOURCE_$(date +%s)" > /app/controller/.lucid-source-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_SIDECAR_$(date +%s)" > /app/sidecar/.lucid-sidecar-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_DISCOVERY_$(date +%s)" > /app/discovery/.lucid-discovery-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_COMMUNICATION_$(date +%s)" > /app/communication/.lucid-communication-marker && \
    echo "LUCID_SERVICE_MESH_CONTROLLER_SECURITY_$(date +%s)" > /app/security/.lucid-security-marker && \
    test -f /app/controller/.lucid-source-marker || (echo "ERROR: Failed to create controller marker" && exit 1) && \
    test -f /app/sidecar/.lucid-sidecar-marker || (echo "ERROR: Failed to create sidecar marker" && exit 1) && \
    test -f /app/discovery/.lucid-discovery-marker || (echo "ERROR: Failed to create discovery marker" && exit 1) && \
    test -f /app/communication/.lucid-communication-marker || (echo "ERROR: Failed to create communication marker" && exit 1) && \
    test -f /app/security/.lucid-security-marker || (echo "ERROR: Failed to create security marker" && exit 1) && \
    chown -R 65532:65532 /app || (echo "ERROR: Failed to chown /app" && exit 1)

# Build the application (fail on compilation errors)
# CRITICAL: compileall returns non-zero on errors, verify compilation succeeded
RUN python -m compileall -b . > /tmp/compile.log 2>&1; \
    compile_exit=$?; \
    if [ $compile_exit -ne 0 ]; then \
        echo "ERROR: Python compilation failed (exit code: $compile_exit)" && \
        cat /tmp/compile.log && \
        exit 1; \
    fi && \
    test -d ./controller || (echo "ERROR: controller directory missing after compilation" && exit 1) && \
    echo "✅ Python compilation successful"

# Verify system libraries exist in builder stage before COPY (per Dockerfile-copy-pattern)
# CRITICAL: This ensures COPY operations will not fail silently
RUN test -f /lib/ld-linux-aarch64.so.1 || (echo "ERROR: /lib/ld-linux-aarch64.so.1 not found in builder stage" && exit 1) && \
    test -d /lib/aarch64-linux-gnu || (echo "ERROR: /lib/aarch64-linux-gnu directory not found in builder stage" && exit 1) && \
    test -f /etc/ssl/certs/ca-certificates.crt || (echo "ERROR: /etc/ssl/certs/ca-certificates.crt not found in builder stage" && exit 1) && \
    echo "✅ System libraries verified in builder stage: dynamic linker, arch-specific libs, CA certificates"

# Stage 2: Runtime (Distroless) - use TARGETPLATFORM for final image
FROM --platform=$TARGETPLATFORM gcr.io/distroless/python3-debian12

# Set build arguments for labels
ARG BUILD_DATE
ARG VCS_REF
ARG VERSION=1.0.0
ARG TARGETPLATFORM=linux/arm64

# Set metadata labels (aligned with essentials.md)
LABEL maintainer="Lucid Development Team" \
      org.opencontainers.image.title="Lucid Service Mesh Controller" \
      org.opencontainers.image.description="Distroless service mesh controller for Lucid platform" \
      org.opencontainers.image.version="${VERSION}" \
      org.opencontainers.image.created="${BUILD_DATE}" \
      org.opencontainers.image.revision="${VCS_REF}" \
      org.opencontainers.image.vendor="Lucid" \
      org.opencontainers.image.licenses="MIT" \
      lucid.service="service-mesh-controller" \
      lucid.type="distroless" \
      lucid.platform="arm64" \
      lucid.security="hardened" \
      phase="2" \
      cluster="10-cross-cluster-integration"

# Set working directory
WORKDIR /app

# Create site-packages directory before COPY (distroless doesn't have it)
# CRITICAL: Use /usr/local (SAME PATTERN AS auth/Dockerfile - standard location for distroless)
RUN ["/usr/bin/python3", "-c", "import os; os.makedirs('/usr/local/lib/python3.11/site-packages', exist_ok=True); os.makedirs('/usr/local/bin', exist_ok=True); print('✅ Created site-packages directories')"]

# Copy runtime directories from builder (directory already populated with .keep files)
COPY --from=builder --chown=65532:65532 /var/run /var/run
COPY --from=builder --chown=65532:65532 /var/lib /var/lib

# Verify runtime directories were copied (per Dockerfile-copy-pattern: verify after COPY)
# CRITICAL: Verify both marker files AND directory structure (prevents silent COPY failures)
RUN ["/usr/bin/python3", "-c", "import os, sys; assert os.path.exists('/var/run/.keep'), 'ERROR: Runtime directory marker not copied: /var/run/.keep'; assert os.path.exists('/var/lib/.keep'), 'ERROR: Lib directory marker not copied: /var/lib/.keep'; assert os.path.isdir('/var/run'), 'ERROR: /var/run is not a directory'; assert os.path.isdir('/var/lib'), 'ERROR: /var/lib is not a directory'; assert os.path.isfile('/var/run/.keep'), 'ERROR: /var/run/.keep is not a file'; assert os.path.isfile('/var/lib/.keep'), 'ERROR: /var/lib/.keep is not a file'; print('✅ Runtime directories verified in runtime stage: markers and structure confirmed')"]

# Copy Python packages (directory already populated with packages + marker files from builder stage)
# CRITICAL: Copy to /usr/local (SAME PATTERN AS auth/Dockerfile line 184 - standard location for distroless)
# CRITICAL: Copy entire directories (not individual files) per Dockerfile-copy-pattern
COPY --from=builder --chown=65532:65532 /root/.local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder --chown=65532:65532 /root/.local/bin /usr/local/bin

# Copy dynamic linker for ARM64 (required for native extensions like grpcio)
COPY --from=builder /lib/ld-linux-aarch64.so.1 /lib/ld-linux-aarch64.so.1

# Copy arch-specific libraries directory (required for ARM64 native extensions)
COPY --from=builder /lib/aarch64-linux-gnu /lib/aarch64-linux-gnu

# Copy CA certificates (required for SSL/TLS operations)
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/ca-certificates.crt

# Verify system libraries were copied (per Dockerfile-copy-pattern: verify after COPY)
# CRITICAL: This will fail the build if system libraries are missing (prevents silent failures)
# CRITICAL: Verify file types and sizes to ensure complete copy (not empty or partial)
RUN ["/usr/bin/python3", "-c", "import os, sys; linker = '/lib/ld-linux-aarch64.so.1'; lib_dir = '/lib/aarch64-linux-gnu'; certs = '/etc/ssl/certs/ca-certificates.crt'; assert os.path.exists(linker), f'ERROR: Dynamic linker not copied: {linker}'; assert os.path.isfile(linker), f'ERROR: {linker} is not a file'; assert os.path.getsize(linker) > 0, f'ERROR: {linker} is empty'; assert os.path.isdir(lib_dir), f'ERROR: Arch-specific libs not copied: {lib_dir}'; assert len(os.listdir(lib_dir)) > 0, f'ERROR: {lib_dir} is empty'; assert os.path.exists(certs), f'ERROR: CA certificates not copied: {certs}'; assert os.path.isfile(certs), f'ERROR: {certs} is not a file'; assert os.path.getsize(certs) > 0, f'ERROR: {certs} is empty'; print('✅ System libraries verified in runtime stage: all files exist, have correct types, and are non-empty')"]

# Verify packages were copied (this will fail the build if packages are missing)
# CRITICAL: Use correct import names (grpc not grpcio, consul not python_consul)
# CRITICAL: Use /usr/local path (SAME PATTERN AS auth/Dockerfile line 191 - standard location)
# CRITICAL: Verify both package directories exist AND packages can be imported AND marker file has content (per Dockerfile-copy-pattern)
# CRITICAL: Add site-packages to sys.path before importing (distroless Python doesn't include /usr/local by default)
RUN ["/usr/bin/python3", "-c", "import os, importlib, importlib.util, sys; site_packages = '/usr/local/lib/python3.11/site-packages'; bin_dir = '/usr/local/bin'; sys.path.insert(0, site_packages); assert os.path.exists(site_packages), f'ERROR: {site_packages} does not exist'; assert os.path.isdir(site_packages), f'ERROR: {site_packages} is not a directory'; assert os.path.exists(bin_dir), f'ERROR: {bin_dir} does not exist'; assert os.path.isdir(bin_dir), f'ERROR: {bin_dir} is not a directory'; required = ('grpc', 'aiohttp', 'consul', 'pydantic', 'cryptography', 'yaml'); failed = [pkg for pkg in required if not importlib.util.find_spec(pkg)]; assert len(failed) == 0, f'ERROR: Packages cannot be imported: {failed}'; [importlib.import_module(pkg) for pkg in required]; assert os.path.exists(os.path.join(site_packages, 'grpc')), 'ERROR: grpc directory not found'; assert os.path.exists(os.path.join(site_packages, 'aiohttp')), 'ERROR: aiohttp directory not found'; assert os.path.exists(os.path.join(site_packages, 'consul')), 'ERROR: consul directory not found'; assert os.path.exists(os.path.join(site_packages, 'pydantic')), 'ERROR: pydantic directory not found'; assert os.path.exists(os.path.join(site_packages, 'cryptography')), 'ERROR: cryptography directory not found'; assert os.path.exists(os.path.join(site_packages, 'yaml')) or os.path.exists(os.path.join(site_packages, 'yaml.py')), 'ERROR: yaml not found'; marker_path = os.path.join(site_packages, '.lucid-marker'); bin_marker_path = os.path.join(bin_dir, '.lucid-marker'); assert os.path.exists(marker_path), f'ERROR: marker file not found: {marker_path}'; assert os.path.exists(bin_marker_path), f'ERROR: bin marker file not found: {bin_marker_path}'; assert os.path.getsize(marker_path) > 0, f'ERROR: marker file is empty: {marker_path}'; assert os.path.getsize(bin_marker_path) > 0, f'ERROR: bin marker file is empty: {bin_marker_path}'; print('✅ Packages verified in runtime stage: directories exist, imports work, and marker files have content')"]

# Copy application code from builder (directory already populated with source + marker files)
COPY --from=builder --chown=65532:65532 /app /app

# Verify controller module and entrypoint exist (this will fail the build if missing)
# CRITICAL: Verify all source directories AND marker files AND module can be imported (per Dockerfile-copy-pattern)
# CRITICAL: Add site-packages to sys.path before importing (controller imports yaml which is in site-packages)
RUN ["/usr/bin/python3", "-c", "import os, importlib.util, sys; site_packages = '/usr/local/lib/python3.11/site-packages'; sys.path.insert(0, site_packages); assert os.path.exists('/app/controller'), 'ERROR: /app/controller missing'; assert os.path.isdir('/app/controller'), 'ERROR: /app/controller is not a directory'; assert os.path.exists('/app/sidecar'), 'ERROR: /app/sidecar missing'; assert os.path.exists('/app/discovery'), 'ERROR: /app/discovery missing'; assert os.path.exists('/app/communication'), 'ERROR: /app/communication missing'; assert os.path.exists('/app/security'), 'ERROR: /app/security missing'; assert os.path.exists('/app/entrypoint.py'), 'ERROR: /app/entrypoint.py missing'; assert os.path.isfile('/app/entrypoint.py'), 'ERROR: /app/entrypoint.py is not a file'; assert os.path.exists('/app/controller/.lucid-source-marker'), 'ERROR: controller marker missing'; assert os.path.exists('/app/sidecar/.lucid-sidecar-marker'), 'ERROR: sidecar marker missing'; assert os.path.exists('/app/discovery/.lucid-discovery-marker'), 'ERROR: discovery marker missing'; assert os.path.exists('/app/communication/.lucid-communication-marker'), 'ERROR: communication marker missing'; assert os.path.exists('/app/security/.lucid-security-marker'), 'ERROR: security marker missing'; spec = importlib.util.find_spec('controller.main', package=None); assert spec is not None, 'ERROR: controller.main module not found'; print('✅ controller package and entrypoint verified in runtime stage: all directories, markers, and module imports verified')"]

# Locale and Timezone Configuration (distroless-compatible: C.UTF-8)
ENV TZ=UTC \
    LANG=C.UTF-8 \
    LC_ALL=C.UTF-8 \
    COUNTRY=US

# Set Python path and environment (packages already copied above)
# CRITICAL: Use /usr/local path (SAME PATTERN AS auth/Dockerfile - standard location)
ENV PYTHONPATH=/app:/usr/local/lib/python3.11/site-packages \
    PATH=/usr/local/bin:/usr/local/bin:/usr/bin:/bin \
    PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    LUCID_ENV=production \
    LUCID_PLATFORM=arm64 \
    LUCID_ARCHITECTURE=linux/arm64

# Service Configuration (per essentials.md and Network_conig_requirements.md lines 307-360)
ENV SERVICE_NAME=service-mesh-controller \
    CONTAINER_NAME=lucid-service-mesh-controller \
    HOSTNAME=lucid-service-mesh-controller

# Port Configuration
ENV PORT=8500 \
    SERVICE_MESH_CONTROLLER_PORT=8500 \
    HTTP_PORT=8088 \
    HEALTHCHECK_PORT=8088 \
    HEALTHCHECK_PATH=/health

# Network Configuration (per Network_conig_requirements.md lines 334-341)
ENV SERVICE_MESH_CONTROLLER_HOST=172.20.0.19 \
    SERVICE_DISCOVERY_URL=http://lucid-service-mesh-controller:8500 \
    SERVICE_MESH_ENABLED=true

# Consul Configuration (per Network_conig_requirements.md lines 334-341)
ENV CONSUL_PORT=8500 \
    CONSUL_DATACENTER=lucid-dc \
    CONSUL_BOOTSTRAP_EXPECT=1 \
    CONSUL_UI_ENABLED=true \
    CONSUL_CONNECT_ENABLED=true \
    CONSUL_NODE_NAME=lucid-service-mesh-controller

# Database Configuration (per Network_conig_requirements.md - if needed)
# Note: MONGODB_PASSWORD will be provided via .env files at runtime
ENV MONGODB_URI=mongodb://lucid:${MONGODB_PASSWORD:-changeme}@lucid-mongodb:27017/lucid?authSource=admin \
    REDIS_URL=redis://lucid-redis:6379/0

# Project Configuration (per path_plan.md)
ENV PROJECT_ROOT=/mnt/myssd/Lucid/Lucid \
    PROJECT_NAME=Lucid \
    PROJECT_VERSION=0.1.0

# Logging Configuration (per path_plan.md)
ENV LOG_LEVEL=INFO \
    DEBUG=false \
    LOG_FORMAT=json

# Network Configuration (per network_defs.md)
ENV LUCID_PI_NETWORK=lucid-pi-network \
    LUCID_PI_SUBNET=172.20.0.0/16 \
    LUCID_PI_GATEWAY=172.20.0.1

# Use nonroot user (distroless default)
USER 65532:65532

# Health check (aligned with HTTP endpoint on port 8088)
# CRITICAL: Uses HTTP endpoint /health for Docker healthcheck
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD ["/usr/bin/python3", "-c", "import urllib.request; urllib.request.urlopen('http://localhost:8088/health').read(); exit(0)"]

# Expose ports (aligned with essentials.md and Network_conig_requirements.md: 8500,8501,8502,8600,8088)
EXPOSE 8500 8501 8502 8600 8088

# Start application using entrypoint script (more reliable than inline CMD)
# CRITICAL: Use ENTRYPOINT + CMD pattern (same as auth/Dockerfile) for distroless compatibility
# CRITICAL: Entrypoint script handles Python path setup and yaml verification
# CRITICAL: PYTHONPATH is already set in ENV (line 287), entrypoint ensures sys.path is correct
ENTRYPOINT ["/usr/bin/python3"]
CMD ["/app/entrypoint.py"]
