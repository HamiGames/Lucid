# LUCID RDP Network Diagnostics - Network Troubleshooting and Analysis
# SPEC-4 Compliant: Network monitoring, packet analysis, connectivity testing

FROM alpine:3.20 AS base

LABEL org.lucid.plane="ops"
LABEL org.lucid.service="network-diagnostics"
LABEL org.lucid.stage="1"

# Install network diagnostic tools
RUN apk add --no-cache \
    tcpdump \
    wireshark-cli \
    nmap \
    mtr \
    traceroute \
    netstat-nat \
    ss \
    iproute2 \
    iptables \
    bind-tools \
    curl \
    wget \
    jq \
    python3 \
    py3-pip \
    && rm -rf /var/cache/apk/*

# Install Python networking libraries
RUN pip3 install --no-cache-dir \
    scapy==2.5.0 \
    psutil==5.9.6 \
    requests==2.31.0 \
    aiohttp==3.9.1 \
    prometheus-client==0.19.0

# Create diagnostics directory
WORKDIR /opt/lucid/network-diagnostics

# Copy network diagnostic scripts
COPY <<EOF /opt/lucid/network-diagnostics/network-analyzer.py
#!/usr/bin/env python3
"""
LUCID RDP Network Analyzer
SPEC-4 compliant network diagnostics and monitoring
"""

import asyncio
import json
import logging
import os
import socket
import subprocess
import time
from typing import Dict, List, Optional
import psutil
import requests
from scapy.all import *
from prometheus_client import start_http_server, Counter, Gauge, Histogram

class NetworkAnalyzer:
    def __init__(self):
        self.metrics_port = int(os.getenv('METRICS_PORT', '9090'))
        self.analysis_interval = int(os.getenv('ANALYSIS_INTERVAL', '30'))
        
        # Prometheus metrics
        self.packet_count = Counter('lucid_packets_total', 'Total packets processed', ['protocol', 'direction'])
        self.connection_count = Gauge('lucid_connections_active', 'Active network connections')
        self.bandwidth_usage = Gauge('lucid_bandwidth_bytes', 'Bandwidth usage in bytes', ['interface', 'direction'])
        self.latency_histogram = Histogram('lucid_latency_seconds', 'Network latency distribution')
        
    async def analyze_connections(self) -> Dict:
        """Analyze active network connections"""
        connections = []
        for conn in psutil.net_connections(kind='inet'):
            connections.append({
                'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else None,
                'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                'status': conn.status,
                'pid': conn.pid,
                'family': conn.family.name,
                'type': conn.type.name
            })
        
        self.connection_count.set(len(connections))
        return {'connections': connections, 'total': len(connections)}
    
    async def analyze_bandwidth(self) -> Dict:
        """Analyze network bandwidth usage"""
        interfaces = {}
        for interface, stats in psutil.net_io_counters(pernic=True).items():
            interfaces[interface] = {
                'bytes_sent': stats.bytes_sent,
                'bytes_recv': stats.bytes_recv,
                'packets_sent': stats.packets_sent,
                'packets_recv': stats.packets_recv,
                'errin': stats.errin,
                'errout': stats.errout,
                'dropin': stats.dropin,
                'dropout': stats.dropout
            }
            
            # Update Prometheus metrics
            self.bandwidth_usage.labels(interface=interface, direction='sent').set(stats.bytes_sent)
            self.bandwidth_usage.labels(interface=interface, direction='recv').set(stats.bytes_recv)
        
        return {'interfaces': interfaces}
    
    async def test_connectivity(self, targets: List[str]) -> Dict:
        """Test connectivity to specified targets"""
        results = {}
        for target in targets:
            start_time = time.time()
            try:
                response = requests.get(f"http://{target}", timeout=5)
                latency = time.time() - start_time
                self.latency_histogram.observe(latency)
                results[target] = {
                    'status': 'reachable',
                    'latency': latency,
                    'response_code': response.status_code
                }
            except Exception as e:
                results[target] = {
                    'status': 'unreachable',
                    'error': str(e)
                }
        return results
    
    async def capture_packets(self, interface: str = 'any', count: int = 100) -> List[Dict]:
        """Capture and analyze network packets"""
        packets = []
        try:
            # Use scapy to capture packets
            sniffed = sniff(iface=interface, count=count, timeout=10)
            
            for packet in sniffed:
                packet_info = {
                    'timestamp': packet.time,
                    'src': packet.src if hasattr(packet, 'src') else None,
                    'dst': packet.dst if hasattr(packet, 'dst') else None,
                    'protocol': packet.proto if hasattr(packet, 'proto') else None,
                    'size': len(packet)
                }
                packets.append(packet_info)
                
                # Update Prometheus metrics
                if packet_info['protocol']:
                    self.packet_count.labels(
                        protocol=str(packet_info['protocol']),
                        direction='inbound' if packet_info['dst'] == '127.0.0.1' else 'outbound'
                    ).inc()
        
        except Exception as e:
            logging.error(f"Packet capture error: {e}")
        
        return packets
    
    async def run_analysis(self):
        """Run comprehensive network analysis"""
        logging.info("Starting network analysis...")
        
        # Start Prometheus metrics server
        start_http_server(self.metrics_port)
        logging.info(f"Prometheus metrics available on port {self.metrics_port}")
        
        while True:
            try:
                # Run analysis tasks
                connections = await self.analyze_connections()
                bandwidth = await self.analyze_bandwidth()
                connectivity = await self.test_connectivity(['google.com', 'cloudflare.com'])
                
                # Log results
                logging.info(f"Analysis complete - Connections: {connections['total']}, "
                           f"Interfaces: {len(bandwidth['interfaces'])}")
                
                await asyncio.sleep(self.analysis_interval)
                
            except Exception as e:
                logging.error(f"Analysis error: {e}")
                await asyncio.sleep(5)

async def main():
    analyzer = NetworkAnalyzer()
    await analyzer.run_analysis()

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    asyncio.run(main())
EOF

# Make network analyzer executable
RUN chmod +x /opt/lucid/network-diagnostics/network-analyzer.py

# Create network test script
COPY <<EOF /opt/lucid/network-diagnostics/network-test.sh
#!/bin/bash
# Network diagnostic test script

echo "=== LUCID Network Diagnostics ==="

echo "1. Testing basic connectivity..."
ping -c 3 8.8.8.8

echo "2. Testing DNS resolution..."
nslookup google.com

echo "3. Testing port connectivity..."
nc -zv google.com 80

echo "4. Network interface status..."
ip addr show

echo "5. Routing table..."
ip route show

echo "6. Active connections..."
ss -tuln

echo "âœ… Network diagnostics complete"
EOF

RUN chmod +x /opt/lucid/network-diagnostics/network-test.sh

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD curl -f http://localhost:9090/metrics || exit 1

# Expose metrics and diagnostic API
EXPOSE 9090 8089

# Volume for packet captures
VOLUME ["/var/captures"]

# Entry point
CMD ["/opt/lucid/network-diagnostics/network-analyzer.py"]
